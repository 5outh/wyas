(define (not x)     (if x #f #t))
(define (null? obj) (if (eqv? obj '()) #t #f))
(define (list . objs) objs)
(define (id obj) obj)
(define (flip f) (lambda (x y) (f y x)))
(define (curry f a) (lambda (x) (apply f (cons a (list x)))))
(define (compose f g) (lambda (x) (f (apply g x))))
(define zero? (curry = 0))
(define positive? (curry > 0))
(define negative? (curry < 0))
(define (odd? num) (= 1 (mod num 2)))
(define (even? num) (= 0 (mod num 2)))
(define (foldr f acc xs)
  (if (null? xs)
      acc
      (f (car xs) (foldr f acc (cdr xs)))))
(define (foldl f acc xs)
  (if (null? xs)
      acc
      (foldl f (f acc (car xs)) (cdr xs))))
(define fold foldl)
(define reduce foldr)
(define (unfold f init p)
  (if (p init)
      (cons init '())
      (cons init (unfold f (f init) p))))
(define (sum . lst)     (fold +  0  lst))
(define (product . lst) (fold *  1  lst))
(define (and . lst)     (fold && #t lst))
(define (or . lst)      (fold || #f lst))
(define (max x . xs) (fold (lambda (old new) (if (> new old) new old) x xs)))
(define (min x . xs) (fold (lambda (old new) (if (< new old) new old) x xs)))
(define (length lst) (fold (lambda (x acc) (+ acc 1)) 0 lst))
(define (reverse lst) (fold (flip cons) '() lst))
(define (mem-helper p f) (lambda (acc next) (if (and (not acc) (p (f next))) next acc)))
(define (memq obj lst)       (fold (mem-helper (curry eq? obj) id) #f lst))
(define (memv obj lst)       (fold (mem-helper (curry eqv? obj) id) #f lst))
(define (member obj lst)     (fold (mem-helper (curry equal? obj) id) #f lst))
(define (assq obj alist)     (fold (mem-helper (curry eq? obj) car) #f alist))
(define (assv obj alist)     (fold (mem-helper (curry eqv? obj) car) #f alist))
(define (assoc obj alist)    (fold (mem-helper (curry equal? obj) car) #f alist))
(define (map f lst) (foldr (lambda (x acc) (cons (f x) acc)) '() lst))
(define (filter p lst) (foldr (lambda (x acc) (if (p x) (cons x acc) acc)) '() lst))
